from collections import defaultdict

from rich import print
import polars as pl
from surprise import KNNWithMeans, Reader, Trainset, Prediction
from surprise import Dataset as SurpriseDataset

from utils.types import RecommendResult, Dataset, DFData, DFUserMovies, DFMovieRatingPred, DFUserMoviesPred
from recommenders.base_recommend import BaseRecommender


class KNNCollabFilteringRecommender(BaseRecommender):
    """
    A recommender system based on K-Nearest Neighbors (KNN) with collaborative filtering.

    Attributes
    ----------
    `dataset : Dataset`
        The dataset used for the recommender system.

    Methods
    -------
    `recommend() -> RecommendResult`
        Generates recommendations using KNN with collaborative filtering.
    """
    def __init__(self, dataset: Dataset) -> None:
        super().__init__(dataset=dataset)

    def recommend(self) -> RecommendResult:
        """
        Generates recommendations using KNN with collaborative filtering.

        Returns
        -------
        `RecommendResult`
            The result of the recommendation, including predicted movie ratings and predicted movies for each user.
        """
        df_train: DFData = self.dataset.df_train
        df_test: DFData = self.dataset.df_test
        df_user_movies_test: DFUserMovies = self.dataset.df_user_movies_test

        reader: Reader = Reader(rating_scale=(0.5, 5))
        trainset: Trainset = SurpriseDataset.load_from_df(
            df=df_train[['user_id', 'movie_id', 'rating']].to_pandas(),
            reader=reader,
        ).build_full_trainset()

        # 類似度を計算する方法を指定する, user_based: False でアイテムベースとなる
        sim_options: dict = {'name': 'pearson', 'user_based': True}
        knn: KNNWithMeans = KNNWithMeans(k=30, min_k=1, sim_options=sim_options)
        knn.fit(trainset=trainset)

        # testデータのrating予測
        rating_preds = []
        for user_id, movie_id in df_test[['user_id', 'movie_id']].to_numpy():
            prediction: Prediction = knn.predict(uid=user_id, iid=movie_id)
            rating_pred: float = prediction.est
            rating_preds.append(rating_pred)

        df_movie_rating_pred: DFMovieRatingPred = (
            df_test
            .select(['user_id', 'movie_id', 'rating'])
            .with_columns(rating_pred=pl.Series(rating_preds))
        )

        # ユーザごとに推薦映画を予測
        testset: list[tuple[int, int, float]] = trainset.build_anti_testset()
        predictions: list[Prediction] = knn.test(testset=testset)
        user_movies_pred: dict[str, list] = self._pred_top_n_movies(predictions=predictions)
        df_user_movies_pred: DFUserMoviesPred = (
            df_user_movies_test
            .join(pl.DataFrame(user_movies_pred), on='user_id', how='left')
        )

        return RecommendResult(df_movie_rating_pred=df_movie_rating_pred, df_user_movies_pred=df_user_movies_pred)
    
    def _pred_top_n_movies(self, predictions: list[Prediction], n: int = 10) -> dict[str, list]:
        """
        Predicts the top n movies for each user based on the provided predictions.

        Parameters
        ----------
        `predictions : list[Prediction]`
            The list of predictions generated by the KNN model.
        `n : int, optional`
            The number of top movies to predict for each user (default is 10).

        Returns
        -------
        `dict[str, list]`
            A dictionary where the keys are user IDs and the values are lists of predicted movie IDs.
        """
        # 各ユーザーごとに、予測されたアイテムを格納する
        user_predictions: dict[int, list[tuple[int, float]]] = defaultdict(list)
        for user_id, item_id, true_rating, pred_rating, _ in predictions:
            user_predictions[user_id].append((item_id, pred_rating))

        # ユーザーごとに、アイテムを予測評価値順に並べ上位n個を格納する
        user_movies_pred: dict[str, list] = defaultdict(list)
        for user_id, user_ratings in user_predictions.items():
            user_ratings: list[tuple[int, float]] = sorted(user_ratings, key=lambda x: x[1], reverse=True)[:n]
            recommend_movies: list[int] = [item_id for item_id, rating in user_ratings]
            user_movies_pred['user_id'].append(user_id)
            user_movies_pred['movie_id_pred'].append(recommend_movies)

        return user_movies_pred
